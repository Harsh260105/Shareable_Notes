// Google Gemini API utilities
// Using Gemini API for AI-powered text analysis
//
// IMPORTANT: 
// - This implementation complies with Google Gemini API Terms of Service
// - The AI-generated content should not be used for medical, legal, or financial advice
// - Results may occasionally be inaccurate or inappropriate
// - Applications must be used only by users 18 years or older
// - Users should review AI-generated content before relying on it

// API key from environment variables - required for Gemini API
const GOOGLE_API_KEY = import.meta.env.VITE_GOOGLE_AI_API_KEY;
// If no API key is provided, don't attempt to make API calls
if (!GOOGLE_API_KEY) {
    console.error('Missing Gemini API key. Please add VITE_GOOGLE_AI_API_KEY to your .env file.');
}
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

const callGeminiApi = async (text, prompt) => {
    // Check if API key is available
    if (!GOOGLE_API_KEY) {
        throw new Error('Gemini API key is not configured. Please add it to your environment variables.');
    }

    try {
        const url = `${GEMINI_API_URL}?key=${GOOGLE_API_KEY}`;
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [
                    {
                        parts: [
                            { text: prompt },
                            { text: text }
                        ]
                    }
                ],
                generationConfig: {
                    temperature: 0.2,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 1024,
                },
                safetySettings: [
                    {
                        category: "HARM_CATEGORY_HARASSMENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    },
                    {
                        category: "HARM_CATEGORY_HATE_SPEECH",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    },
                    {
                        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    },
                    {
                        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    }
                ]
            }),
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Gemini API request failed: ${error}`);
        }

        return await response.json();
    } catch (error) {
        console.error(`Error calling Gemini API:`, error);
        throw error;
    }
};


export const analyzeSentiment = async (text) => {
    if (!text || text.trim().length < 10) return { sentiment: 'neutral', score: 0.5, analysis: 'Not enough text to analyze.' };

    try {
        const prompt = `Analyze the sentiment of the following text. 
        Provide a detailed analysis of the emotional tone, attitude, and overall sentiment.
        Return the result as a JSON object with:
        - "sentiment": a single word describing the overall sentiment (positive, negative, neutral, mixed)
        - "score": a number from 0.0 (extremely negative) to 1.0 (extremely positive) with 0.5 being neutral
        - "analysis": a brief 1-2 sentence analysis of the sentiment
        - "emotions": an array of up to 3 key emotions detected in the text
        Format: {"sentiment": "positive", "score": 0.8, "analysis": "The text expresses enthusiasm and satisfaction.", "emotions": ["joy", "satisfaction", "optimism"]}`;

        const response = await callGeminiApi(text, prompt);

        const responseText = response.candidates[0].content.parts[0].text;

        const jsonMatch = responseText.match(/{[\s\S]*}/);
        if (!jsonMatch) {
            return { sentiment: 'neutral', score: 0.5, analysis: 'Unable to analyze sentiment.' };
        }

        try {
            return JSON.parse(jsonMatch[0]);
        } catch (parseError) {
            console.error('Error parsing sentiment JSON:', parseError);
            return { sentiment: 'neutral', score: 0.5, analysis: 'Error analyzing sentiment.' };
        }
    } catch (error) {
        console.error('Error analyzing sentiment:', error);
        return { sentiment: 'neutral', score: 0.5, analysis: 'Error analyzing sentiment.' };
    }
};

export const getAiContentDisclaimer = () => {
    return {
        general: "Content generated by AI may not always be accurate. Please review before using.",
        medical: "Do not use this for medical advice. Consult a healthcare professional for medical concerns.",
        legal: "This is not legal advice. Consult a qualified attorney for legal matters.",
        financial: "This is not financial advice. Consult a financial professional for financial decisions."
    };
};

/**
 * Extract key terms from text using Gemini API
 * @param {string} text - The text to analyze
 * @returns {Promise<Array>} - Array of key terms with type and definition
 */
export const extractKeyTerms = async (text) => {
    if (!text || text.trim().length < 10) return [];

    try {
        const prompt = `Extract the 10 most important key terms from the following text. 
        For each term, determine its type (person, location, organization, concept, etc.) and provide a brief definition.
        Return the result as a JSON array with objects containing: "term" (the term itself), "type" (lowercase category), 
        "definition" (brief description), and "salience" (importance score from 0.0 to 1.0).
        Format: [{"term": "example", "type": "concept", "definition": "brief definition", "salience": 0.8}, ...]`;

        const response = await callGeminiApi(text, prompt);

        // Parse the JSON from the response text
        const responseText = response.candidates[0].content.parts[0].text;

        // Extract JSON array from the response (handling potential text around the JSON)
        const jsonMatch = responseText.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
            return [];
        }

        try {
            const keyTerms = JSON.parse(jsonMatch[0]);
            return keyTerms.slice(0, 10); // Ensure we only return max 10 terms
        } catch (parseError) {
            console.error('Error parsing key terms JSON:', parseError);
            return [];
        }
    } catch (error) {
        console.error('Error extracting key terms:', error);
        return [];
    }
};


export const checkGrammar = async (text) => {
    if (!text || text.trim().length < 10) return [];

    try {
        const prompt = `Analyze the following text for grammar, spelling, and style issues.
        Focus only on grammatical correctness, not on content accuracy or advice.
        For each issue found, return a JSON array of objects with:
        - "text" (the problematic text)
        - "type" (grammar, spelling, style, etc.)
        - "suggestions" (array of possible corrections)
        - "severity" (suggestion, warning, error)
        Format: [{"text": "problematic text", "type": "grammar", "suggestions": ["correction1", "correction2"], "severity": "suggestion"}, ...]
        If no issues are found, return an empty array.`;

        const response = await callGeminiApi(text, prompt);

        // Parse the JSON from the response text
        const responseText = response.candidates[0].content.parts[0].text;

        // Extract JSON array from the response
        const jsonMatch = responseText.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
            return [];
        }

        try {
            return JSON.parse(jsonMatch[0]);
        } catch (parseError) {
            console.error('Error parsing grammar issues JSON:', parseError);
            return [];
        }
    } catch (error) {
        console.error('Error checking grammar:', error);
        return [];
    }
};

/**
 * Generate summary using Gemini API
 * Note: Summaries are AI-generated and may occasionally contain inaccuracies.
 * They should not be used for critical decision-making without human review.
 * 
 * @param {string} text - The text to summarize
 * @returns {Promise<string>} - Generated summary
 */
export const generateSummary = async (text) => {
    if (!text || text.trim().length < 20) return '';

    try {
        const prompt = `Provide a concise 1-2 sentence summary of the following text. 
        Focus on the main topics and sentiment. Keep it brief but informative.
        Do not include medical, legal, or financial advice.`;

        const response = await callGeminiApi(text, prompt);

        // Extract the summary text from the response
        const summary = response.candidates[0].content.parts[0].text.trim();
        return summary;
    } catch (error) {
        console.error('Error generating summary:', error);
        return 'Error generating summary.';
    }
};

/**
 * Generate word cloud data using Gemini API
 * @param {string} text - The text to analyze
 * @returns {Promise<Array>} - Array of word cloud items with text, value, and color
 */
export const generateWordCloud = async (text) => {
    if (!text || text.trim().length < 20) return [];

    try {
        const prompt = `Extract the 25 most important words or phrases from the following text for a word cloud visualization.
        For each word/phrase, assign a relevance score (1-100) and categorize it as one of these types:
        PERSON, LOCATION, ORGANIZATION, EVENT, WORK_OF_ART, CONSUMER_GOOD, CONCEPT, or OTHER.
        Return a JSON array with objects containing: "text" (the word/phrase), "value" (relevance score 1-100), and "type" (category).
        Format: [{"text": "example", "value": 85, "type": "CONCEPT"}, ...]`;

        const response = await callGeminiApi(text, prompt);

        // Parse the JSON from the response text
        const responseText = response.candidates[0].content.parts[0].text;

        // Extract JSON array from the response
        const jsonMatch = responseText.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
            return [];
        }

        try {
            const words = JSON.parse(jsonMatch[0]);

            // Generate colors based on entity type
            const typeColors = {
                PERSON: '#4299e1',      // blue
                LOCATION: '#48bb78',    // green
                ORGANIZATION: '#ed8936', // orange
                EVENT: '#9f7aea',       // purple
                WORK_OF_ART: '#f56565', // red
                CONSUMER_GOOD: '#ecc94b', // yellow
                CONCEPT: '#805ad5',     // purple
                OTHER: '#a0aec0',       // gray
            };

            // Map to the expected format with colors
            return words.map(word => ({
                text: word.text,
                value: word.value,
                color: typeColors[word.type] || typeColors.OTHER,
            })).slice(0, 25);
        } catch (parseError) {
            console.error('Error parsing word cloud JSON:', parseError);
            return [];
        }
    } catch (error) {
        console.error('Error generating word cloud:', error);
        return [];
    }
};

/**
 * Find related notes based on content similarity using Gemini API
 * @param {string} currentNoteText - The text of the current note
 * @param {Array} allNotes - Array of all notes to compare against
 * @returns {Promise<Array>} - Array of related note IDs with similarity score
 */
export const findRelatedNotes = async (currentNoteText, allNotes) => {
    if (!currentNoteText || !allNotes || allNotes.length === 0) return [];

    try {
        // If there are only a few notes, we can simply analyze each one against the current note
        if (allNotes.length <= 5) {
            const results = [];

            for (const note of allNotes) {
                // Skip comparing to self
                if (note.content === currentNoteText) continue;

                // Extract plain text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content;
                const noteText = tempDiv.textContent || tempDiv.innerText;

                if (noteText.length < 20) continue;

                const prompt = `On a scale of 0 to 1, rate how semantically related the following two text passages are.
                Consider themes, subjects, concepts, and tone. Return ONLY a JSON object in this format: 
                {"similarity": 0.75, "reason": "brief explanation of why"}`;

                // Combine both texts with clear separation
                const combinedText = `PASSAGE 1:\n${currentNoteText}\n\nPASSAGE 2:\n${noteText}`;

                const response = await callGeminiApi(combinedText, prompt);
                const responseText = response.candidates[0].content.parts[0].text;

                // Extract the JSON object
                const jsonMatch = responseText.match(/{[\s\S]*}/);
                if (jsonMatch) {
                    try {
                        const result = JSON.parse(jsonMatch[0]);
                        if (result.similarity > 0.4) { // Only include if similarity is significant
                            results.push({
                                id: note.id,
                                title: note.title,
                                similarity: result.similarity,
                            });
                        }
                    } catch (parseError) {
                        console.error('Error parsing similarity JSON:', parseError);
                    }
                }
            }

            return results
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 5);
        }
        // For many notes, we'll use a more efficient approach with a single API call
        else {
            // Get the current note themes and topics
            const prompt = `Extract the main themes, topics, and key concepts from this text. 
            Then, analyze the following notes and identify the top 5 most related ones based on thematic similarity.
            Each note has an ID and content.`;

            // Prepare a condensed version of all notes
            const noteDigests = allNotes.map(note => {
                // Skip the current note or extract plain text
                if (note.content === currentNoteText) return null;

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content;
                const noteText = tempDiv.textContent || tempDiv.innerText;

                if (noteText.length < 20) return null;

                // For long notes, just use the beginning
                const digestText = noteText.length > 200 ?
                    noteText.substring(0, 200) + "..." :
                    noteText;

                return {
                    id: note.id,
                    title: note.title,
                    digest: digestText
                };
            }).filter(note => note !== null);

            if (noteDigests.length === 0) return [];

            // Combine the current note with digests of all other notes
            const combinedText = `MAIN NOTE:\n${currentNoteText}\n\nOTHER NOTES:\n` +
                noteDigests.map(note => `ID: ${note.id}\nTITLE: ${note.title}\nCONTENT: ${note.digest}`).join('\n\n');

            const finalPrompt = `${prompt}\n\nReturn a JSON array of the 5 most related notes with their similarity scores:
            [{"id": "note-id", "title": "note title", "similarity": 0.75}, ...]`;

            const response = await callGeminiApi(combinedText, finalPrompt);
            const responseText = response.candidates[0].content.parts[0].text;

            // Extract the JSON array
            const jsonMatch = responseText.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                try {
                    return JSON.parse(jsonMatch[0]);
                } catch (parseError) {
                    console.error('Error parsing related notes JSON:', parseError);
                    return [];
                }
            }

            return [];
        }
    } catch (error) {
        console.error('Error finding related notes:', error);
        return [];
    }
};
